import os
import json
from datetime import datetime, time
from typing import List, Dict, Optional, Any
from supabase import create_client, Client
from langchain_core.tools import tool

# Initialize Supabase Client
url: str = os.environ.get("SUPABASE_URL", "")
key: str = os.environ.get("SUPABASE_KEY", "")

# Initialize client only if credentials are present
supabase: Optional[Client] = None
if url and key:
    supabase = create_client(url, key)

@tool
def search_rooms(room_type: Optional[str] = None, status: str = 'available') -> str:
    """Search for hotel rooms based on type and status.
    Args:
        room_type: Optional type of room (e.g., 'Single', 'Double', 'Suite').
        status: Status of the room (default: 'available').
    Returns:
        A JSON string containing the list of matching rooms.
    """
    if not supabase:
        return "Error: Supabase client not initialized."

    query = supabase.table("rooms").select("*").eq("status", status)
    
    if room_type:
        query = query.eq("room_type", room_type)
        
    response = query.execute()
    return json.dumps(response.data, indent=2)

@tool
def book_room(room_id: int, guest_name: str, check_in: str, check_out: str) -> str:
    """Book a hotel room for a guest.
    Args:
        room_id: The ID of the room to book.
        guest_name: Name of the guest.
        check_in: Check-in date (YYYY-MM-DD).
        check_out: Check-out date (YYYY-MM-DD).
    Returns:
        A success message or error description.
    """
    if not supabase:
        return "Error: Supabase client not initialized."

    # 1. Check if room is available
    room_check = supabase.table("rooms").select("status").eq("id", room_id).execute()
    if not room_check.data or room_check.data[0]['status'] != 'available':
        return f"Error: Room {room_id} is not available."

    # 2. Create Booking
    booking_data = {
        "room_id": room_id,
        "guest_name": guest_name,
        "check_in": check_in,
        "check_out": check_out
    }
    booking_res = supabase.table("bookings").insert(booking_data).execute()

    # 3. Update Room Status
    supabase.table("rooms").update({"status": "booked"}).eq("id", room_id).execute()

    # 4. Record Transaction (Income) automatically
    # Assuming payment is made upon booking for simplicity in this demo
    room_price_res = supabase.table("rooms").select("price_per_night").eq("id", room_id).execute()
    price = room_price_res.data[0]['price_per_night'] if room_price_res.data else 0
    
    add_transaction(
        amount=price, 
        category="Income", 
        description=f"Room Booking: {room_id} for {guest_name}"
    )

    return f"Successfully booked room {room_id} for {guest_name}. Transaction recorded."

@tool
def update_room_status(room_id: int, new_status: str) -> str:
    """Update the status of a specific room (e.g., to 'maintenance' or 'available').
    Args:
        room_id: The ID of the room.
        new_status: The new status ('available', 'booked', 'maintenance').
    Returns:
        Confirmation message.
    """
    if not supabase:
        return "Error: Supabase client not initialized."
        
    response = supabase.table("rooms").update({"status": new_status}).eq("id", room_id).execute()
    return f"Room {room_id} status updated to {new_status}."

@tool
def add_transaction(amount: float, category: str, description: str) -> str:
    """Record a financial transaction (Income or Expense).
    Args:
        amount: The monetary value (positive for income, negative for expense).
        category: Category of transaction (e.g., 'Income', 'Salary', 'Maintenance').
        description: Brief description of the transaction.
    Returns:
        Confirmation of the recorded transaction.
    """
    if not supabase:
        return "Error: Supabase client not initialized."

    # Business Rule: Daily close at 13:00 (1:00 PM)
    # If current time is after 13:00, this transaction belongs to the 'next' accounting day logically,
    # but strictly chronologically it's just recorded with current timestamp.
    # The 'daily_summary' report will handle the cutoff logic.
    
    data = {
        "amount": amount,
        "category": category,
        "description": description,
        # created_at is auto-generated by Supabase
    }
    
    response = supabase.table("transactions").insert(data).execute()
    return "Transaction recorded successfully."

@tool
def get_daily_report(date: str) -> str:
    """Generate a daily financial report closing at 13:00 (1:00 PM).
    The report covers from 13:00 of the previous day to 13:00 of the specified date.
    Args:
        date: The target date for the report (YYYY-MM-DD).
    Returns:
        A summarized report of total income, expenses, and net balance.
    """
    if not supabase:
        return "Error: Supabase client not initialized."

    # Logic: Report for '2025-01-02' covers:
    # Start: 2025-01-01 13:00:00
    # End:   2025-01-02 13:00:00
    
    target_date = datetime.strptime(date, "%Y-%m-%d")
    
    # Calculate cutoff timestamps (Simplification: dealing with strings/ISO for Supabase)
    # Ideally, handle timezones properly. Assuming UTC or server local time consistency.
    
    # We need to query range. Since supabase-py filter logic with datetime is specific,
    # we'll fetch wider range or use raw sql if possible, but filter is safer here.
    
    # Note: For this demo, let's fetch all transactions for the broad 2-day window and filter in python
    # to ensure the 13:00 cutoff logic is precise.
    
    response = supabase.table("transactions").select("*").execute()
    transactions = response.data
    
    total_income = 0.0
    total_expense = 0.0
    count = 0
    
    # Filter logic for 13:00 cutoff
    # Target Report Date: '2025-01-02'
    # Covers: 2025-01-01 13:00:00 <= created_at < 2025-01-02 13:00:00
    
    try:
        current_cutoff = datetime.strptime(f"{date} 13:00:00", "%Y-%m-%d %H:%M:%S")
        # Previous day calculation could be done better with timedelta, 
        # but for simplicity assuming daily usage.
        # Ideally, we query the DB with filters directly.
        
        # Let's perform a direct DB query with date filters for efficiency and accuracy
        # Note: Supabase/Postgres uses ISO format.
        
        from datetime import timedelta
        prev_cutoff = current_cutoff - timedelta(days=1)
        
        # Convert to ISO strings for Supabase query
        start_iso = prev_cutoff.isoformat()
        end_iso = current_cutoff.isoformat()
        
        # Query Transactions within the window
        # .gte('created_at', start_iso).lt('created_at', end_iso)
        res = supabase.table("transactions").select("*")\
            .gte("created_at", start_iso)\
            .lt("created_at", end_iso)\
            .execute()
            
        transactions = res.data
        
        report_lines = [
            f"=== Daily Financial Report ===",
            f"Date: {date}",
            f"Period: {prev_cutoff} to {current_cutoff}",
            "-" * 40
        ]
        
        total_income = 0.0
        total_expense = 0.0
        
        if not transactions:
            report_lines.append("No transactions found for this period.")
        else:
            for tx in transactions:
                amt = float(tx['amount'])
                desc = tx.get('description', '-')
                cat = tx.get('category', 'Misc')
                
                # Formula: Positive = Income, Negative or Expense Category = Expense
                # Adjust logic based on your preferred data entry style. 
                # Here assuming 'amount' carries the sign or category dictates it.
                # Let's assume standard accounting: 
                # If category is 'Income', amount is added.
                # If category is 'Expense', amount is subtracted (or tracked as expense).
                
                if cat.lower() == 'income' or amt > 0:
                    total_income += abs(amt)
                    report_lines.append(f"[+] {amt:,.2f} | {cat} | {desc}")
                else:
                    total_expense += abs(amt)
                    report_lines.append(f"[-] {abs(amt):,.2f} | {cat} | {desc}")

        net_balance = total_income - total_expense
        
        report_lines.append("-" * 40)
        report_lines.append(f"Total Income:   {total_income:,.2f}")
        report_lines.append(f"Total Expense:  {total_expense:,.2f}")
        report_lines.append(f"Net Balance:    {net_balance:,.2f}")
        report_lines.append("=" * 40)
        
        return "\n".join(report_lines)

    except Exception as e:
        return f"Error generating report: {str(e)}"

